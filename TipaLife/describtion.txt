Игра программ - Вирусы.

==============================================================================================
Описание:
**********************

На поле (квадратное, размер от 20х20) случайно кидается от 2-х до 10 экземпляров вирусов каждого класса (от 2-х до 6 классов).
Каждый экземпляр вируса случайно получает управление.

Поучив управление, вирус может:
- либо ПОЙТИ* в любом из 8 направлений, 
- либо ПОМОЧЬ* в любом из 8 направлений.

ПОЙТИ ***
Ход вируса зависит от того, свободно ли поле куда он собирается пойти.
1. Если поле свободно, осуществляется перемещение. 

2. Если поле занято чужим вирусом, происходит атака. 
При этом, у чужого (атакуемого) вируса отнимается половина жизни атакующего. 
И, после этого, атакующий получает ответ в виде отнимания половины оставшейся жизни у того, на кого он напал.
(пусть вирус Q с жизнью 100 атакует вирус W с жизнью 100. после атаки будет у Q 75, у W 50).
При достижении уровня жизни отметки 0, вирус умирает.

3. Если поле занято своим вирусом, происходит размножение. 
При этом появляется новый экземпляр вируса того же класса, что и родители, с жизнью = половина жизни родителя (кто инициировал рождение).
Рожденный экземпляр появляется на соседнем с родителем поле.
Рождение возможно, только если на соседнем с родителем поле есть место.

ПОМОЧЬ ***
Отнимаеся жизнь у вируса (в любом случае) и передается по направлению. 
Если там, куда происходит передача, стоит враг - он тоже получит помощь. 
Если там, куда происходит передача, никого нет - помощь уйдет в никуда (никто не получит ее).
В любом случае жизнь у помогающего вируса отнимется.

Периодически происходит увеличение жизни всех вирусов на всем поле.

СМЫСЛ: 
********************************************
Играющий пишет программу действий для своего класса вирусов, с целью остаться на поле только этому классу вирусов.
Писать надо в синтаксисе Delphi. 
Эта программа пока тупо подставляется между begin и end, компилится в *.dll, после чего dll грузится и всем вирусам присваится адрес экспортной процедурки.
Интерпретатор здорово грузит из-за работы со строками + могу ошибится, а тут все готово.
Можно, конечно использовать всякие asm push XX бла-бла-бла pop XX end; :) 
Но считать это не спортивным и предать анафеме :) 

Подробности:
 tMyAction=procedure(MLL,N,O,S,W,NO,SO,SW,NW,NL,OL,SL,WL,NOL,SOL,SWL,NWL:integer; var MVR,ACT,DX,DY,HLP:integer);
 tSoldier=class
  public
    MyAction:tMyAction;
и соответственно,
   RNDS:=random(length(Soldiers)); //случайный солдат получает управление
   if Soldiers[RNDS]<>nil then
   begin
     SetAroundForSoldier(Soldiers[RNDS]);   //пересчитываются переменные N,O,S,W,NO...

     if addr(Soldiers[RNDS].MyAction)<>Nil  //если есть программа действия, вызывается
      then Soldiers[RNDS].MyAction(
   
   else begin  //если нет действия у вируса-солдата, сходить рандомно
        sign1:=random;       dx:=random(2);       if sign1>0.5 then dx:=dx*(-1);
        sign2:=random;       dy:=random(2);       if sign2>0.5 then dy:=dy*(-1);
     end;

library GetAction; exports GetActionA name 'GetAction';
Procedure GetActionA(MLL,N,O,S,W,NO,SO,SW,NW,NL,OL,SL,WL,NOL,SOL,SWL,NWL:integer; var MVR,ACT,DX,DY,HLP:integer);
function RND:integer;  var    sign:double;  begin    sign:=random;    result:=random(2);    if sign>0.5 then result:=result*(-1);  end;
begin
// пример-умолчание. Не подставляется вообщето, но если б подставлялся, то было б тоже самое
  ACT:=0;
  DX:=RND;
  DY:=RND;
  HLP:=0;
end;

**********************
Описание:
==============================================================================================


==============================================================================================
Правила:
**********************

Есть переменные-стороны света. 
(-+. это DX и DY относительно экземпляра вируса. т.е. направлению N (на север(вверх)), соответствует .- (DX=0 DY=-1)

  --   .-    +-
    NV  N  NO

 -. W       O +.

    SW  S  SO
 -+    .+    ++

Данные переменные =1 если там никого и 0 если кто-то есть. 
И -1 если координаты плохие (край)
Те же переменные с L на конце(NL, NOL..) дают уровень жизни с той клетки, 
если там свой. И 0 иначе.

Есть 4 переменные, которые надо вернуть (3 обязательно)
ACT DX DY (HLP) 
ACT = 0 или 1 - Идем или помогаем
DX DY - клетка куда идем или помогаем
HLP - на скока помогаем (от нас отнимется, туда прибавится)

+ Еще одна переменная MLL. (MyLevelLife)
Это свой уровень жизни.

+ Еще одна переменная MVR. (MyVar)
Это память, своя для каждого экземпляра. 
Сюда можно сохранить число, которое останется до следующего получения управления

Функция RND. Вернет случайно -1, или 0, или 1

ИТОГО, Полный список:
const 
MLL,N,O,S,W,NO,SO,SW,NW,NL,OL,SL,WL,NOL,SOL,SWL,NWL:integer; 

var   
MVR,ACT,DX,DY,HLP:integer

+ Функция RND

**********************
Правила:
==============================================================================================

=============================================================================================
Примеры:
**********************

Данная программа по умолчанию
ACT:=0;       //  Действие. 0 - движение, 1 - помощь
DX:=RND;      //  RND функция дающая 1 или 0 или -1 
DY:=RND; 
HLP:=0;      // В принципе, не обязательно в данном случае
//-----------------------------------------------------------------------------


// А Eсли дополнить ее, т.е. еще дописать как ниже - получится вирус-размножитель.
// Быстро захватывает все пространство и выигрывает, если никто из других не успел ничего создать. 
// Иначе, медленно но верно, проиграет.
// Смысл его прораммы - Если хоть одна ххL не =0, 
// значит там свой,значит идем туда размножаться.
ACT:=0;  //сначала сделаем стандартно, чтоб если просчитаемся, хоть что-то делал
DX:=RND;
DY:=RND; 
HLP:=0; 
if NWL<>0 then begin DX:=-1; DY:=-1; end;
if NL<>0 then begin DX:=0; DY:=-1; end;
if NOL<>0 then begin DX:=1; DY:=-1; end;
if OL<>0 then begin DX:=1; DY:=0; end;
if SOL<>0 then begin DX:=1; DY:=1; end;
if SL<>0 then begin DX:=0; DY:=1; end;
if SWL<>0 then begin DX:=-1; DY:=+1; end;
if WL<>0 then begin DX:=-1; DY:=0; end;
//-----------------------------------------------------------------------------

// Случайный, но Исключает простой в действиях, что повышает активность. 
// Уверенно выигрывает у случайного, если воюют уже сформировавшиеся коллонии. 
// если воюют уже сформировавшиеся коллонии проигрывает Воину
ACT:=0; 
repeat 
  DX:=RND;
  DY:=RND;
until (DX<>0) and (DY<>0); 
//-----------------------------------------------------------------------------

// А так получится вирус-воин
// Пинает всех врагов, которых видит.
ACT:=0;  //сначала сделаем стандартно, чтоб если просчитаемся, хоть что-то делал
DX:=RND;
DY:=RND; 
HLP:=0; 
//если там не пусто, но уровень жизни нам не говорят, значит враг. Атаковать.
if (NW=0) and (NWL=0) then begin DX:=-1; DY:=-1; end; 
if (N=0) and (NL=0) then begin DX:=0; DY:=-1; end;
if (NO=0) and (NOL=0) then begin DX:=1; DY:=-1; end;
if (O=0) and (OL=0) then begin DX:=1; DY:=0; end;
if (SO=0) and (SOL=0) then begin DX:=1; DY:=1; end;
if (S=0) and (SL=0) then begin DX:=0; DY:=1; end;
if (SW=0) and (SWL=0) then begin DX:=-1; DY:=+1; end;
if (W=0) and (WL=0) then begin DX:=-1; DY:=0; end;
//-----------------------------------------------------------------------------

// Осторожный воин
ACT:=0;  //сначала сделаем стандартно, чтоб если просчитаемся, хоть что-то делал
DX:=RND;
DY:=RND; 
HLP:=0; 
if MLL<40 then exit; // толков пинаться, если жизни мало и вдруг убьют в ответке
//если там не пусто, но уровень жизни нам не говорят, значит враг. Атаковать.
if (NW=0) and (NWL=0) then begin DX:=-1; DY:=-1; end; 
if (N=0) and (NL=0) then begin DX:=0; DY:=-1; end;
if (NO=0) and (NOL=0) then begin DX:=1; DY:=-1; end;
if (O=0) and (OL=0) then begin DX:=1; DY:=0; end;
if (SO=0) and (SOL=0) then begin DX:=1; DY:=1; end;
if (S=0) and (SL=0) then begin DX:=0; DY:=1; end;
if (SW=0) and (SWL=0) then begin DX:=-1; DY:=+1; end;
if (W=0) and (WL=0) then begin DX:=-1; DY:=0; end;
//-----------------------------------------------------------------------------

// Помощник
ACT:=0;  //сначала сделаем стандартно, чтоб если просчитаемся, хоть что-то делал
DX:=RND;
DY:=RND; 
HLP:=0;
// если в округе тока свои
if (NWL<>0) and (NL<>0) and (NOL<>0) and (OL<>0) and (SOL<>0) and (SL<>0) and (SWL<>0) and (WL<>0)
then if MLL>50 then // если у самого жизни много
begin 
// если у соседа жизни не под завязку, то свыше 50 скинуть ему.
 if (NWL<100) then begin ACT:=1; DX:=-1; DY:=-1; HLP:=MLL-50; exit; end; 
 if (NL<100) then begin ACT:=1; DX:=0; DY:=-1; HLP:=MLL-50; exit; end;
 if (NOL<100) then begin ACT:=1; DX:=1; DY:=-1; HLP:=MLL-50; exit; end;
 if (OL<100) then begin ACT:=1; DX:=1; DY:=0; HLP:=MLL-50; exit; end;
 if (SOL<100) then begin ACT:=1; DX:=1; DY:=1; HLP:=MLL-50; exit; end;
 if (SL<100) then begin ACT:=1; DX:=0; DY:=1; HLP:=MLL-50; exit; end;
 if (SWL<100) then begin ACT:=1; DX:=-1; DY:=+1; HLP:=MLL-50; exit; end;
 if (WL<100) then begin ACT:=1; DX:=-1; DY:=0; HLP:=MLL-50; exit; end;
end; 

**********************
Примеры:
=============================================================================================

Идеи, поправки к правилам, реализации, примеры программ вирусов, критика - принимаются :)